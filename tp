Teaching

Three-letter words: tea, hat, cat, get, age, hit, ace, eat, net, ten
Four-letter words: teach, gate, each, heat, neat
Five-letter words: cheat, thing, night
Anything else: creating
Creation

Three-letter words: cat, eat, tea, art, rat, ten, net, ear, ice, not
Four-letter words: care, neat, race, note, core
Five-letter words: crate, trace, ocean
Anything else: reaction
Stationed

Three-letter words: sit, tan, net, sat, ion, and, tin, set, aid, eat
Four-letter words: note, send, date, sand, tend
Five-letter words: stand, tones, saint
Anything else: sedition
Computer

Three-letter words: cup, top, pet, met, cut, mop, rot, pot, put, rut
Four-letter words: cope, more, term, port, mute
Five-letter words: route, comet, tempo
Anything else: computer
Interact

Three-letter words: cat, ant, eat, tea, net, act, rat, tan, ear, art
Four-letter words: neat, cart, rent, rate, care
Five-letter words: react, trace, cater
Anything else: intricate
Gradient

Three-letter words: ant, eat, tan, art, rat, net, red, get, ten, air
Four-letter words: date, gate, dear, tear, read
Five-letter words: grade, giant, train
Anything else: gradient
Imagines

Three-letter words: mag, age, gin, nag, sin, man, gas, men, aim, sag
Four-letter words: game, mean, sign, same, gain
Five-letter words: image, gains, manga
Anything else: imagine
Painters

Three-letter words: pat, sit, rip, tin, net, tan, air, rat, pan, art
Four-letter words: pair, sent, rain, snap, part
Five-letter words: paint, spain, saint
Anything else: painters
Reaction

Three-letter words: cat, eat, tea, net, act, rat, tan, ion, ear, art
Four-letter words: rate, note, coat, race, neat
Five-letter words: crate, ocean, trace
Anything else: creation
Learning

Three-letter words: ran, leg, gin, ear, nag, rag, lie, air, nil, era
Four-letter words: ring, earn, rain, near, lane
Five-letter words: learn, range, angle
Anything else: learning


import os
import subprocess
from pathlib import Path
import argparse
import copy

class CloudDeploy:
    def __init__(self):
        self._label = 'k8s'
        self._worker_concurrency = '2'
        self.setup_env()

    @property
    def user(self):
        return os.getenv("USER")

    @property
    def hostname(self):
        return os.uname().nodename

    @property
    def cinitccname(self):
        return os.getenv("CINITCCNAME", f"/var/spool/certs/{self.user}")

    @cinitccname.setter
    def cinitccname(self, value):
        os.environ['CINITCCNAME'] = value

    @property
    def docker_host(self):
        return os.getenv('DOCKER_HOST', f"tcp://{self.hostname}:2376")

    @property
    def docker_tls_verify(self):
        return os.getenv('DOCKER_TLS_VERIFY', "1")

    @property
    def docker_cert_path(self):
        return os.getenv('DOCKER_CERT_PATH', f"{self.cinitccname}")

    @property
    def ticket_path(self):
        return Path(f"/var/spool/tickets/{self.user}")

    @property
    def workspace(self):
        workspace_dir = f"/var/tmp/{self.label}-cloud-deploy"
        if not os.path.exists(workspace_dir):
            os.makedirs(workspace_dir)
        return workspace_dir

    @property
    def cloud_deploy_version(self):
        return os.getenv('CLOUD_DEPLOY_VERSION', '2024.05.16-89')

    @property
    def mongo_connection_string(self):
        default_mongo_string = (
            "mongodb://ivapp1388351.devin1.ms.com:27000,ivapp1388351.devin1.ms.com:27000/d_cloud-deploy?"
            "replicaSet=rs&tls=true&tlsCertificateKeyFile=/path/to/combined-cert-key.pem&tlsCAFile=/etc/ssl/certs/ca-bundle.crt&authMechanism=SCRAM-SHA-1"
        )
        return os.getenv('CLOUD_DEPLOY_CONNECTION_STRING', default_mongo_string)

    @property
    def label(self):
        return self._label

    @label.setter
    def label(self, value):
        self._label = value

    @property
    def worker_concurrency(self):
        return self._worker_concurrency

    @worker_concurrency.setter
    def worker_concurrency(self, value):
        self._worker_concurrency = value

    @property
    def docker_env(self):
        env = {
            'CINITCCNAME': self.cinitccname,
            'DOCKER_TLS_VERIFY': self.docker_tls_verify,
            'DOCKER_HOST': self.docker_host,
            'DOCKER_CERT_PATH': self.docker_cert_path,
            'USER': self.user,
            'WORKSPACE': self.workspace,
            'CLOUD_DEPLOY_CONNECTION_STRING': self.mongo_connection_string,
            'CLOUD_DEPLOY_K8S_WORKSPACE_DIR': self.workspace,
            'CLOUD_DEPLOY_WORKER_CONCURRENCY': self.worker_concurrency,
            'CLOUD_DEPLOY_K8S_BASELINE_IMAGE': 'cloud/k8s-baseline',
            'CLOUD_DEPLOY_SSL_CLIENT_CERT_FILE': f"{self.cinitccname}/cert.pem",
            'CLOUD_DEPLOY_SSL_CLIENT_CERT_KEY_FILE': f"{self.cinitccname}/combined-cert-key.pem",
            'CLOUD_DEPLOY_SSL_CLIENT_KEY_FILE': f"{self.cinitccname}/key.pem",
            'CLOUD_DEPLOY_WORKER_LABELS': f"['{self.label}']",
            'KRB5CCNAME': self.cinitccname,
            'GIT_SSL_CERT': f"{self.cinitccname}/cert.pem",
            'GIT_SSL_KEY': f"{self.cinitccname}/key.pem",
            'GIT_HTTP_PROXY_AUTHMETHOD': "negotiate",
            'GIT_SSL_NO_VERIFY': "false",
        }
        return env

    def setup_env(self):
        if self.ticket_path.is_file() and self.ticket_path.stat().st_size > 0:
            self.cinitccname = f"/var/spool/certs/{self.user}"
        else:
            if self.user:
                self.cinitccname = f"/var/spool/certs/{self.user}"
            else:
                print("Error: Unable to determine the current user.")
                exit(1)

        cinitccname_path = Path(self.cinitccname)
        if not cinitccname_path.is_dir():
            print(f"Error: {self.cinitccname} must exist to get client certs")
            exit(1)

    def run_docker_command(self, cmd):
        try:
            env = copy.deepcopy(self.docker_env)
            subprocess.run(cmd, shell=True, check=True, env=env)
        except subprocess.CalledProcessError as e:
            print(f"Error executing command: {e}")

    def status(self, container_name):
        cmd = f"docker inspect --format '{{{{.State.Running}}}}' {container_name}"
        status_result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        return status_result.stdout.strip() == 'true'

    def container_exists(self, container_name):
        cmd = f"docker inspect {container_name}"
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        return result.returncode == 0

    def start(self, container_name=None, worker_concurrency='2', label='k8s'):
        self.label = label
        self.worker_concurrency = worker_concurrency

        if container_name and self.status(container_name):
            print(f"Container {container_name} is already running.")
            return

        env_vars = " ".join([f"-e {key}={value}" for key, value in self.docker_env.items()])
        name_option = f"--name {container_name} " if container_name else ""
        cmd = (
            f"docker run --rm {name_option}"
            f"--cap-drop=NET_BIND_SERVICE "
            f"--cap-drop=SETGID "
            f"--cap-drop=SETUID "
            f"{env_vars} "
            f"--network=host "
            f"--security-opt=no-new-privileges "
            f"-u {os.getuid()}:{os.getgid()} "
            f"-v {self.cinitccname}:{self.cinitccname}:ro "
            f"-v {self.workspace}:{self.workspace}:rw "
            f"-v /etc/nsswitch.conf:/etc/nsswitch.conf:ro "
            f"-v /var/db:/var/db:ro "
            f"msde/cloud-deploy:{self.cloud_deploy_version} "
            f"bin/run-worker.sh"
        )

        try:
            self.run_docker_command(cmd)
        except KeyboardInterrupt:
            print("\nStart command interrupted. You can stop the container manually if needed.")

    def stop(self, container_name):
        if not self.status(container_name):
            print(f"Container {container_name} is already stopped.")
            return

        self.run_docker_command(f"docker stop {container_name}")
        print(f"Container {container_name} is stopped.")

    def restart(self, container_name):
        if self.container_exists(container_name):
            if self.status(container_name):
                self.run_docker_command(f"docker restart {container_name}")
                print(f"Container {container_name} is restarted.")
            else:
                print(f"Container {container_name} is stopped. Starting it...")
                self.start(container_name=container_name)
        else:
            print(f"Container {container_name} does not exist. Starting a new one...")
            self.start(container_name=container_name)

def main():
    parser = argparse.ArgumentParser(description='CloudDeploy control script')
    parser.add_argument('action', choices=['start', 'stop', 'restart'], help='Action to perform')
    parser.add_argument('--container-name', '-c', help='Name of the Docker container')
    parser.add_argument('--worker-concurrency', '-w', default='2', help='Number of worker concurrency')
    parser.add_argument('--label', '-l', default='k8s', help='Cloud-deploy worker label')
    args = parser.parse_args()

    cloud_deploy = CloudDeploy()

    try:
        if args.action == 'start':
            cloud_deploy.start(container_name=args.container_name, worker_concurrency=args.worker_concurrency, label=args.label)
        elif args.action == 'stop':
            if args.container_name:
                cloud_deploy.stop(container_name=args.container_name)
            else:
                print("Error: --container-name is required for stop action.")
        elif args.action == 'restart':
            if args.container_name:
                cloud_deploy.restart(container_name=args.container_name)
            else:
                print("Error: --container-name is required for restart action.")
    except KeyboardInterrupt:
        print("\nAction interrupted.")

if __name__ == "__main__":
    main()

